<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Geospatial Jobs</title>
<link rel="stylesheet" href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css"/>
<script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>
<script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
<script src="https://unpkg.com/deck.gl@8.9.27/dist.min.js"></script>
<script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
<script src="https://cdn.tailwindcss.com"></script>
<style>
  :root { --bg:#0F1115; --panel:#131722; --stroke:#242634; --text:#E7E9EE; --muted:#9AA0AB; --accent:#5563FF;}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--text);font-family:Inter,system-ui}
  #map{position:absolute;inset:0}
  .sidebar{position:absolute;left:0;top:0;bottom:0;width:360px;background:var(--panel);border-right:1px solid var(--stroke);z-index:10;overflow:auto}
  .pill{padding:.5rem .7rem;border:1px solid var(--stroke);border-radius:.7rem;font-size:.8rem;color:var(--muted);cursor:pointer;user-select:none}
  .pill.active{background:var(--accent);color:#fff;border-color:transparent}
  .card{background:var(--panel);border:1px solid var(--stroke);border-radius:.9rem;padding:1rem;margin:1rem}
  .legend{display:flex;height:14px;border:1px solid var(--stroke);border-radius:6px;overflow:hidden}
  .region-btn{background:var(--panel);border:1px solid var(--stroke);color:var(--muted);padding:6px 12px;border-radius:8px;cursor:pointer}
  .region-btn.active{background:var(--accent);color:#fff}
  /* drawer fix: do not block clicks when closed */
  .drawer{position:fixed;left:0;right:0;bottom:0;height:40vh;background:var(--panel);border-top:1px solid var(--stroke);
          transform:translateY(100%);transition:.25s;z-index:40;pointer-events:none}
  .drawer.open{transform:translateY(0);pointer-events:auto}
</style>
</head>
<body>
  <aside class="sidebar">
    <div class="card" style="margin-top:1rem">
      <h1 class="text-xl font-semibold mb-3">Geospatial</h1>
      <div class="flex gap-2">
        <button id="tabMap" class="pill active">Map Visualization</button>
        <button id="tabEO"  class="pill">Earth Observation jobs</button>
        <button id="tabVE"  class="pill">Vector Enrichment jobs</button>
      </div>
    </div>

    <div class="card">
      <div class="flex items-center justify-between mb-2">
        <h2 class="font-semibold">Layers</h2>
        <!-- Import data is optional; renderer is how you choose the visualization -->
        <button id="btnImport" class="bg-indigo-500 text-white text-sm px-3 py-1 rounded-md">Import data</button>
        <input id="fileInput" type="file" accept=".csv,.geojson,.json" hidden/>
      </div>

      <label class="text-sm text-gray-400">Renderer</label>
      <select id="renderer" class="w-full bg-transparent border border-[color:var(--stroke)] rounded-md px-2 py-1 mb-3">
        <option value="clusters" selected>Clusters / Points</option>
        <option value="heatmap">Heatmap</option>
        <option value="hexgrid">Hex grid (Vector enrichment)</option>
      </select>

      <label class="text-sm text-gray-400">Color based on</label>
      <select id="attr" class="w-full bg-transparent border border-[color:var(--stroke)] rounded-md px-2 py-1 mb-3">
        <option value="count">count</option>
        <option value="salary">salary</option>
        <option value="experience">experience</option>
      </select>

      <label class="text-sm text-gray-400">Classification</label>
      <select id="classif" class="w-full bg-transparent border border-[color:var(--stroke)] rounded-md px-2 py-1 mb-3">
        <option value="quantile" selected>Quantile (Q5)</option>
        <option value="equal">Equal Interval</option>
      </select>

      <div class="legend mb-1" id="legend"></div>
      <div class="flex justify-between text-xs text-gray-400"><span id="lgLow">low</span><span id="lgHigh">high</span></div>
    </div>

    <div class="card">
      <h2 class="font-semibold mb-2">Filters</h2>
      <select id="country" class="w-full bg-transparent border border-[color:var(--stroke)] rounded-md px-2 py-1 mb-2">
        <option value="">All countries</option>
        <option value="NL">Netherlands</option><option value="DE">Germany</option>
        <option value="FR">France</option><option value="BE">Belgium</option><option value="UK">United Kingdom</option>
      </select>
      <input id="q" placeholder="Filter by company or job" class="w-full bg-transparent border border-[color:var(--stroke)] rounded-md px-2 py-1"/>
    </div>
  </aside>

  <div class="absolute top-4 left-[380px] z-10 flex gap-2">
    <button class="region-btn active" data-region="fit">Fit to Data</button>
    <button class="region-btn" data-region="europe">Europe</button>
    <button class="region-btn" data-region="nl">Netherlands</button>
  </div>

  <div id="map"></div>

  <!-- (If you kept the table drawer from earlier, it will no longer block clicks when closed because of the CSS above) -->

<script>
const CONFIG = {
  STYLE: 'https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json',
  PALETTE: ['#6C1D6B','#9C2C7A','#D4475D','#F07E2E','#FFA600'],
  CLUSTER_RADIUS: 60,
  CLUSTER_MAX_ZOOM: 14,
  HEX_KM: 8
};

const map = new maplibregl.Map({ container:'map', style:CONFIG.STYLE, center:[5.3,52.2], zoom:6.2 });
const deckOverlay = new deck.MapboxOverlay({ interleaved:true, layers:[] });
map.addControl(deckOverlay);

// ----- UI refs
const tabMap = document.getElementById('tabMap');
const tabEO  = document.getElementById('tabEO');
const tabVE  = document.getElementById('tabVE');
const rendererSel = document.getElementById('renderer');
const attrSel = document.getElementById('attr');
const classSel = document.getElementById('classif');
const fileBtn = document.getElementById('btnImport');
const fileInput = document.getElementById('fileInput');
const countrySel = document.getElementById('country');
const qInput = document.getElementById('q');
const legend = document.getElementById('legend');
const lgLow = document.getElementById('lgLow'), lgHigh = document.getElementById('lgHigh');

let raw = null, filtered = null, breaks = [0,0,0,0], currentRenderer = 'clusters';

// ----- sample data
function sampleData(){
  const rows = [
    {city:'Amsterdam',lon:4.8945,lat:52.3667,company:'Leaseweb', job:'SAP Functional Application Manager', country:'NL', count:1, salary:89582, experience:2, type:'Hybrid', date:'2025-03-03'},
    {city:'Amsterdam',lon:4.8945,lat:52.3667,company:'Deloitte',  job:'Junior SAP Consultant', country:'NL', count:1, salary:65754, experience:3, type:'On-site', date:'2025-03-07'},
    {city:'Lieshout', lon:5.5958,lat:51.5194,company:'Royal Swinkels', job:'Junior SAP Application Manager', country:'NL', count:1, salary:89834, experience:2, type:'On-site', date:'2025-03-02'},
    {city:'Utrecht',  lon:5.1214,lat:52.0907,company:'Billennium', job:'SAP Consultant (Remote)', country:'NL', count:1, salary:68849, experience:3, type:'Remote', date:'2025-03-01'},
    {city:'Eindhoven',lon:5.4697,lat:51.4416,company:'SixteenFifty', job:'SAP MM Support Consultant', country:'NL', count:1, salary:72918, experience:3, type:'Hybrid', date:'2025-03-06'}
  ];
  return { type:'FeatureCollection', features: rows.map((r,i)=>({
    type:'Feature',
    geometry:{ type:'Point', coordinates:[r.lon,r.lat] },
    properties:{ id:i, name:r.job, company:r.company, country:r.country,
      count:r.count, salary:r.salary, experience:r.experience, type:r.type, date:r.date }
  }))};
}

// ----- helpers
const toRGB = hex => { const h=hex.replace('#',''); return [parseInt(h.slice(0,2),16),parseInt(h.slice(2,4),16),parseInt(h.slice(4,6),16)]; };
const quantiles = (arr,k)=>{ const a=[...arr].sort((x,y)=>x-y), q=[]; for(let i=1;i<k;i++){ const p=i/k, idx=(a.length-1)*p, lo=Math.floor(idx), hi=Math.ceil(idx); q.push(lo===hi?a[lo]:a[lo]+(a[hi]-a[lo])*(idx-lo)); } return q; };
const equalBreaks=(arr,k)=>{ const mn=Math.min(...arr), mx=Math.max(...arr), step=(mx-mn)/k, b=[]; for(let i=1;i<k;i++) b.push(mn+step*i); return b; };

function computeBreaks(){
  const attr = attrSel.value;
  const vals = (filtered?.features||[]).map(f => +f.properties[attr] || 0);
  if(!vals.length){ breaks=[0,0,0,0]; return; }
  breaks = (classSel.value==='equal' ? equalBreaks(vals, CONFIG.PALETTE.length) : quantiles(vals, CONFIG.PALETTE.length));
  legend.innerHTML = CONFIG.PALETTE.map(c=>`<div style="flex:1;background:${c}"></div>`).join('');
  lgLow.textContent = Math.round(Math.min(...vals)).toLocaleString();
  lgHigh.textContent = Math.round(Math.max(...vals)).toLocaleString();
}

function applyFilters(){
  const iso = countrySel.value, q = qInput.value.trim().toLowerCase();
  filtered = { type:'FeatureCollection', features: (raw?.features||[]).filter(f=>{
    const ok = !iso || f.properties.country===iso;
    const txt = `${f.properties.name} ${f.properties.company}`.toLowerCase();
    return ok && (!q || txt.includes(q));
  })};
}

function fitTo(fc){ if(!fc.features.length) return; const b=turf.bbox(fc); map.fitBounds([[b[0],b[1]],[b[2],b[3]]],{padding:100}); }

// ----- map layers
const SRC='jobs';
const L_CLUSTER='cluster-circles';
const L_CLUSTER_TXT='cluster-text';
const L_POINTS='points';
const L_HEAT='heat';

function ensureLayers(){
  if(!map.getSource(SRC)){
    map.addSource(SRC, {
      type:'geojson',
      data:{type:'FeatureCollection', features:[]},
      cluster:true, clusterRadius:CONFIG.CLUSTER_RADIUS, clusterMaxZoom:CONFIG.CLUSTER_MAX_ZOOM,
      clusterProperties:{
        sum_salary: ['+', ['accumulated'], ['to-number',['get','salary']]],
        sum_experience: ['+', ['accumulated'], ['to-number',['get','experience']]],
        sum_count: ['+', ['accumulated'], ['to-number',['get','count']]]
      }
    });

    map.addLayer({
      id:L_CLUSTER, type:'circle', source:SRC, filter:['has','point_count'],
      paint:{
        'circle-color': ['step',
          ['get','point_count'], CONFIG.PALETTE[0],
          10, CONFIG.PALETTE[1],
          30, CONFIG.PALETTE[2],
          70, CONFIG.PALETTE[3],
          100, CONFIG.PALETTE[4]
        ],
        'circle-radius': ['interpolate',['linear'],['get','point_count'],1,14,100,34],
        'circle-stroke-color':'#0F1115','circle-stroke-width':2,'circle-opacity':0.9
      }
    });
    map.addLayer({
      id:L_CLUSTER_TXT, type:'symbol', source:SRC, filter:['has','point_count'],
      layout:{'text-field':['to-string',['get','point_count']],'text-size':12}, paint:{'text-color':'#fff'}
    });
    map.addLayer({
      id:L_POINTS, type:'circle', source:SRC, filter:['!', ['has','point_count']],
      paint:{
        'circle-color': ['step',
          ['to-number',['get','count']], CONFIG.PALETTE[0],
          1, CONFIG.PALETTE[1], 2, CONFIG.PALETTE[2], 3, CONFIG.PALETTE[3], 5, CONFIG.PALETTE[4]
        ],
        'circle-radius': 7, 'circle-stroke-color':'#0F1115','circle-stroke-width':1.5,'circle-opacity':0.9
      }
    });
    map.addLayer({
      id:L_HEAT, type:'heatmap', source:SRC,
      paint:{
        'heatmap-opacity':0.9,'heatmap-radius':30,'heatmap-intensity':1.1,
        'heatmap-color': ['interpolate',['linear'],['heatmap-density'],
          0,'rgba(0,0,0,0)', .3,'#3aa0ff', .6,'#ffd166', .8,'#ff8c42', 1,'#ff4d4d']
      }
    });
    map.setLayoutProperty(L_HEAT,'visibility','none');

    // cluster click -> fit leaves
    map.on('click', L_CLUSTER, e=>{
      const f=e.features?.[0]; if(!f) return;
      map.getSource(SRC).getClusterLeaves(f.properties.cluster_id, Infinity, 0, (err, leaves)=>{
        if(err||!leaves?.length) return;
        const fc={type:'FeatureCollection',features:leaves};
        const b=turf.bbox(fc);
        map.fitBounds([[b[0],b[1]],[b[2],b[3]]],{padding:120,maxZoom:18});
      });
    });

    // point click -> popup
    map.on('click', L_POINTS, e=>{
      const f=e.features?.[0]; if(!f) return;
      const p=f.properties, [lon,lat]=f.geometry.coordinates;
      new maplibregl.Popup({offset:12}).setLngLat([lon,lat]).setHTML(
        `<div style="min-width:220px">
           <div class="font-semibold mb-1">${p.name}</div>
           <div class="text-xs text-gray-400 mb-1">${p.company}</div>
           <div class="text-sm">Jobs: <b>${p.count}</b> · Salary: <b>€${(+p.salary||0).toLocaleString()}</b> · Exp: <b>${p.experience}y</b></div>
           <div class="text-sm">Type: <b>${p.type||''}</b> · Date: <b>${p.date||''}</b></div>
           <div class="text-[11px] text-gray-400 mt-1">${lat.toFixed(4)}, ${lon.toFixed(4)}</div>
         </div>`).addTo(map);
    });
  }
}

function updateColors(){
  // points by chosen attribute
  const attr = attrSel.value;
  let pointExpr;
  if(attr==='count'){
    pointExpr = ['step',['to-number',['get','count']], CONFIG.PALETTE[0],
      breaks[0], CONFIG.PALETTE[1], breaks[1], CONFIG.PALETTE[2], breaks[2], CONFIG.PALETTE[3], breaks[3], CONFIG.PALETTE[4]];
  }else{
    pointExpr = ['step',['to-number',['get',attr]], CONFIG.PALETTE[0],
      breaks[0], CONFIG.PALETTE[1], breaks[1], CONFIG.PALETTE[2], breaks[2], CONFIG.PALETTE[3], breaks[3], CONFIG.PALETTE[4]];
  }
  map.setPaintProperty(L_POINTS,'circle-color', pointExpr);

  // heatmap weight
  if(attr==='count'){
    map.setPaintProperty(L_HEAT,'heatmap-weight', 1);
  }else{
    map.setPaintProperty(L_HEAT,'heatmap-weight',
      ['interpolate',['linear'],['to-number',['get',attr]], breaks[0],0.1, breaks[3],1]);
  }

  // clusters — use count or averages for salary/experience
  let clusterValue = ['get','point_count'];
  if(attr==='salary') clusterValue = ['/', ['get','sum_salary'], ['max',1,['get','point_count']]];
  if(attr==='experience') clusterValue = ['/', ['get','sum_experience'], ['max',1,['get','point_count']]];

  map.setPaintProperty(L_CLUSTER, 'circle-color', ['step', clusterValue,
    CONFIG.PALETTE[0], breaks[0], CONFIG.PALETTE[1], breaks[1], CONFIG.PALETTE[2], breaks[2], CONFIG.PALETTE[3], breaks[3], CONFIG.PALETTE[4]
  ]);
}

function setRenderer(kind){
  currentRenderer = kind;
  const show = (id,vis)=> map.getLayer(id) && map.setLayoutProperty(id,'visibility',vis?'visible':'none');
  if(kind==='clusters'){ show(L_CLUSTER,true); show(L_CLUSTER_TXT,true); show(L_POINTS,true); show(L_HEAT,false); deckOverlay.setProps({layers:[]}); }
  else if(kind==='heatmap'){ show(L_CLUSTER,false); show(L_CLUSTER_TXT,false); show(L_POINTS,false); show(L_HEAT,true); deckOverlay.setProps({layers:[]}); }
  else { // hex grid via deck.gl
    show(L_CLUSTER,false); show(L_CLUSTER_TXT,false); show(L_POINTS,false); show(L_HEAT,false);
    renderHexGrid();
  }
}

function renderHexGrid(){
  if(!filtered?.features?.length){ deckOverlay.setProps({layers:[]}); return; }
  const bbox = turf.bbox(filtered);
  const grid = turf.hexGrid(bbox, CONFIG.HEX_KM, {units:'kilometers'});
  const pts = turf.featureCollection(filtered.features.map(f=>turf.point(f.geometry.coordinates)));
  const filled=[];
  grid.features.forEach(cell=>{
    const inside = turf.pointsWithinPolygon(pts, cell).features.length;
    if(inside>0){ cell.properties.count=inside; filled.push(cell); }
  });
  const fc=turf.featureCollection(filled);
  const breaksCnt = quantiles(fc.features.map(f=>f.properties.count), CONFIG.PALETTE.length);

  const poly = new deck.GeoJsonLayer({
    id:'hex-polys', data:fc, stroked:false, filled:true, pickable:true, opacity:.85,
    getFillColor: f=>{
      const v=f.properties.count;
      const idx = v<=breaksCnt[0]?0 : v<=breaksCnt[1]?1 : v<=breaksCnt[2]?2 : v<=breaksCnt[3]?3 : 4;
      const [r,g,b]=toRGB(CONFIG.PALETTE[idx]); return [r,g,b,220];
    }
  });
  const labels = new deck.TextLayer({
    id:'hex-labels', data:fc.features.map(f=>({pos:turf.centroid(f).geometry.coordinates, t:String(f.properties.count)})),
    getPosition:d=>d.pos, getText:d=>d.t, getSize:16, getColor:[255,255,255,255], getTextAnchor:'middle', getAlignmentBaseline:'center'
  });
  deckOverlay.setProps({layers:[poly,labels]});
}

function refresh(){
  applyFilters();
  computeBreaks();
  map.getSource(SRC)?.setData(filtered);
  updateColors();
  if(currentRenderer==='hexgrid') renderHexGrid();
}

// ----- UI wiring
tabMap.onclick = ()=>{ [tabMap,tabEO,tabVE].forEach(b=>b.classList.remove('active')); tabMap.classList.add('active'); rendererSel.value='clusters'; setRenderer('clusters'); fitTo(filtered); };
tabEO.onclick  = ()=>{ [tabMap,tabEO,tabVE].forEach(b=>b.classList.remove('active')); tabEO.classList.add('active'); rendererSel.value='clusters'; setRenderer('clusters'); /* light EO filter if you want */ fitTo(filtered); };
tabVE.onclick  = ()=>{ [tabMap,tabEO,tabVE].forEach(b=>b.classList.remove('active')); tabVE.classList.add('active'); rendererSel.value='hexgrid'; setRenderer('hexgrid'); fitTo(filtered); };

rendererSel.onchange = ()=> setRenderer(rendererSel.value);
attrSel.onchange = refresh;
classSel.onchange = refresh;
countrySel.onchange = refresh;
qInput.oninput = refresh;

fileBtn.onclick = ()=> fileInput.click();
fileInput.onchange = (e)=>{
  const f=e.target.files?.[0]; if(!f) return;
  const reader=new FileReader();
  reader.onload=()=>{
    try{
      if(f.name.toLowerCase().endsWith('.csv')){
        const parsed=Papa.parse(reader.result,{header:true, dynamicTyping:true, skipEmptyLines:true});
        const header = Object.keys(parsed.data[0]||{}).reduce((m,k)=>{m[k.toLowerCase()]=k;return m;},{});
        const lonK=header.lon||header.longitude||header.lng, latK=header.lat||header.latitude;
        raw={type:'FeatureCollection', features: parsed.data.map((r,i)=>{
          const lon=+r[lonK], lat=+r[latK]; if(!isFinite(lon)||!isFinite(lat)) return null;
          return {type:'Feature',geometry:{type:'Point',coordinates:[lon,lat]},
            properties:{ id:i, name:r.title||r.role||'Job', company:r.company||'', country:r.country||'',
              count:+(r.count||1)||1, salary:+(r.salary||0)||0, experience:+(r.experience||0)||0, type:r.type||'', date:r.date||'' }};
        }).filter(Boolean)};
      }else{
        const j=JSON.parse(reader.result);
        raw = j.type==='FeatureCollection'? j : {type:'FeatureCollection', features:j.features||[]};
      }
      refresh(); fitTo(filtered);
    }catch(err){ alert('Failed to load: '+err.message); }
  };
  reader.readAsText(f);
};

// ----- bootstrap
map.on('load', ()=>{
  ensureLayers();
  raw = sampleData();       // <-- example data loaded by default
  refresh();
  fitTo(filtered);
});
</script>
</body>
</html>
